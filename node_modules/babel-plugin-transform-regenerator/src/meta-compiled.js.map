{"version":3,"sources":["meta.js"],"names":[],"mappings":";;AAUA;;;;AAEA;;IAAY,C;;;;;;AADZ,IAAI,IAAI,QAAQ,SAAR,EAAmB,YAAnB,EAAR,C,CAXA;;;;;;;;;;AAaA,IAAI,SAAS,OAAO,SAAP,CAAiB,cAA9B;;AAEA,SAAS,aAAT,CAAuB,YAAvB,EAAqC,UAArC,EAAiD;AAC/C,WAAS,YAAT,CAAsB,IAAtB,EAA4B;AAC1B,MAAE,UAAF,CAAa,IAAb;;AAEA;AACA,QAAI,SAAS,KAAb;;AAEA,aAAS,KAAT,CAAe,KAAf,EAAsB;AACpB,UAAI,MAAJ,EAAY;AACV;AACD,OAFD,MAEO,IAAI,MAAM,OAAN,CAAc,KAAd,CAAJ,EAA0B;AAC/B,cAAM,IAAN,CAAW,KAAX;AACD,OAFM,MAEA,IAAI,EAAE,MAAF,CAAS,KAAT,CAAJ,EAAqB;AAC1B,yBAAO,WAAP,CAAmB,MAAnB,EAA2B,KAA3B;AACA,iBAAS,UAAU,KAAV,CAAT;AACD;AACD,aAAO,MAAP;AACD;;AAED,QAAI,OAAO,EAAE,YAAF,CAAe,KAAK,IAApB,CAAX;AACA,QAAI,IAAJ,EAAU;AACR,WAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,KAAK,MAAzB,EAAiC,GAAjC,EAAsC;AACpC,YAAI,MAAM,KAAK,CAAL,CAAV;AACA,YAAI,QAAQ,KAAK,GAAL,CAAZ;AACA,cAAM,KAAN;AACD;AACF;;AAED,WAAO,MAAP;AACD;;AAED,WAAS,SAAT,CAAmB,IAAnB,EAAyB;AACvB,MAAE,UAAF,CAAa,IAAb;;AAEA,QAAI,OAAO,EAAE,IAAF,CAAX;AACA,QAAI,OAAO,IAAP,CAAY,IAAZ,EAAkB,YAAlB,CAAJ,EACE,OAAO,KAAK,YAAL,CAAP;;AAEF;AACA;AACA,QAAI,OAAO,IAAP,CAAY,WAAZ,EAAyB,KAAK,IAA9B,CAAJ,EACE,OAAO,KAAK,YAAL,IAAqB,KAA5B;;AAEF,QAAI,OAAO,IAAP,CAAY,UAAZ,EAAwB,KAAK,IAA7B,CAAJ,EACE,OAAO,KAAK,YAAL,IAAqB,IAA5B;;AAEF,WAAO,KAAK,YAAL,IAAqB,aAAa,IAAb,CAA5B;AACD;;AAED,YAAU,YAAV,GAAyB,YAAzB;;AAEA,SAAO,SAAP;AACD;;AAED,IAAI,cAAc;AAChB,sBAAoB;AADJ,CAAlB;;AAIA;AACA;AACA,IAAI,kBAAkB;AACpB,kBAAgB,IADI,EACE;AACtB,kBAAgB,IAFI,EAEE;AACtB,mBAAiB,IAHG,EAGG;AACvB,oBAAkB,IAJE,EAII;AACxB,wBAAsB,IALF,EAKQ;AAC5B,oBAAkB,IANE,EAMI;AACxB,iBAAe,IAPK,CAOA;AAPA,CAAtB;;AAUA;AACA,IAAI,YAAY;AACd,mBAAiB,IADH;AAEd,kBAAgB,IAFF;AAGd,qBAAmB,IAHL;AAId,mBAAiB,IAJH;AAKd,kBAAgB;AALF,CAAhB;;AAQA;AACA,KAAK,IAAI,IAAT,IAAiB,SAAjB,EAA4B;AAC1B,MAAI,OAAO,IAAP,CAAY,SAAZ,EAAuB,IAAvB,CAAJ,EAAkC;AAChC,oBAAgB,IAAhB,IAAwB,UAAU,IAAV,CAAxB;AACD;AACF;;AAED,QAAQ,cAAR,GAAyB,cAAc,gBAAd,EAAgC,eAAhC,CAAzB;AACA,QAAQ,YAAR,GAAuB,cAAc,cAAd,EAA8B,SAA9B,CAAvB","file":"meta-compiled.js","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\nimport assert from \"assert\";\nlet m = require(\"private\").makeAccessor();\nimport * as t from \"babel-types\";\nlet hasOwn = Object.prototype.hasOwnProperty;\n\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    t.assertNode(node);\n\n    // Assume no side effects until we find out otherwise.\n    let result = false;\n\n    function check(child) {\n      if (result) {\n        // Do nothing.\n      } else if (Array.isArray(child)) {\n        child.some(check);\n      } else if (t.isNode(child)) {\n        assert.strictEqual(result, false);\n        result = predicate(child);\n      }\n      return result;\n    }\n\n    let keys = t.VISITOR_KEYS[node.type];\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        let key = keys[i];\n        let child = node[key];\n        check(child);\n      }\n    }\n\n    return result;\n  }\n\n  function predicate(node) {\n    t.assertNode(node);\n\n    let meta = m(node);\n    if (hasOwn.call(meta, propertyName))\n      return meta[propertyName];\n\n    // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n    if (hasOwn.call(opaqueTypes, node.type))\n      return meta[propertyName] = false;\n\n    if (hasOwn.call(knownTypes, node.type))\n      return meta[propertyName] = true;\n\n    return meta[propertyName] = onlyChildren(node);\n  }\n\n  predicate.onlyChildren = onlyChildren;\n\n  return predicate;\n}\n\nlet opaqueTypes = {\n  FunctionExpression: true\n};\n\n// These types potentially have side effects regardless of what side\n// effects their subexpressions have.\nlet sideEffectTypes = {\n  CallExpression: true, // Anything could happen!\n  ForInStatement: true, // Modifies the key variable.\n  UnaryExpression: true, // Think delete.\n  BinaryExpression: true, // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true, // Side-effecting by definition.\n  UpdateExpression: true, // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n};\n\n// These types are the direct cause of all leaps in control flow.\nlet leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n};\n\n// All leap types are also side effect types.\nfor (let type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\n\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);\n"]}